import{u as y,H as w,I as g,h as k,J as m,K as b,L as P,a as T}from"./index-BIf49YX_.js";async function C(s){const t=await fetch(`/cs/meta/${s}`);if(t.status===404)return{remoteMeta:{version:w().version,tracks:0},ETag:"*"};if(!t.ok)throw new Error(`Failed to get cloud sync manifest. Status: ${t.status}`);const e=t.headers.get("ETag")||"";return{remoteMeta:await t.json(),ETag:e}}async function E(s,t,e){if(t.length===0&&e.length===0)return;const n=await fetch(`/cs/tracks/${s}`,{method:"PUT",body:JSON.stringify({added:t,deleted:e}),headers:{"Content-Type":"application/json"}});if(!n.ok){const a=await n.text();throw console.error("Track update failed. Response:",a),new Error(`Track update failed: ${n.status} ${n.statusText} - ${a}`)}}async function O(s,t){if(t.length===0)return;const e=await fetch(`/.netlify/functions/syncBulkTracks/${s}`,{method:"POST",body:JSON.stringify({addedTrackItems:t}),headers:{"Content-Type":"application/json"}});if(!e.ok){const n=await e.text();throw console.error("Bulk track update failed. Response:",n),new Error(`Bulk track update failed: ${e.status} ${e.statusText} - ${n}`)}}async function v(s){const t=await fetch("/.netlify/functions/syncContent",{method:"POST",body:JSON.stringify(s),headers:{"Content-Type":"application/json"}});if(t.status!==201){const n=await t.text();throw console.error("Immutable content push failed. Response:",n),new Error(`Immutable content push failed: ${t.status} ${t.statusText} - ${n}`)}return(await t.json()).timestamp}async function j(s,t,e){e.tracks||(e.tracks=0);const n=await fetch(`/cs/meta/${s}`,{method:"PUT",headers:{"Content-Type":"application/json","If-Match":t},body:JSON.stringify(e)});if(n.status===412)throw new Error("412 Precondition Failed. Another device made changes. Must pull and re-try.");if(!n.ok)throw new Error("Failed to finalize manifest push.");localStorage.setItem("library_meta",JSON.stringify(e))}async function x(s,t){const e=await fetch(`/.netlify/functions/syncContent/${s}`,{method:"GET"});if(!e.ok)throw new Error(`Failed to pull content for timestamp ${s}.`);const n=await e.json();if(t==="tracks")throw new Error("Do not use pullContentByTimestamp for tracks.");{const a=Array.isArray(n)?n.map(r=>r.id):Object.keys(n);b(t,a)}}async function J(s,t){if(t.length===0)return;const e=await fetch(`/cs/tracks/${s}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok)throw new Error("Failed to pull track metadata by ID.");const n=await e.json();if(n.length>0){const a=m();for(const r of n)a[r.id]=r;P(a)}}let h=null;function I(){T.dbsync&&(h&&clearTimeout(h),h=setTimeout(()=>{B(T.dbsync),h=null},120*1e3))}const p=()=>{const s=localStorage.getItem("dbsync_dirty_tracks");return s?JSON.parse(s):{added:[],deleted:[]}},S=s=>{localStorage.setItem("dbsync_dirty_tracks",JSON.stringify(s))},_=s=>{const t=p();t.added.includes(s)||t.added.push(s),t.deleted=t.deleted.filter(e=>e!==s),S(t)},F=s=>{const t=p();t.deleted.includes(s)||t.deleted.push(s),t.added=t.added.filter(e=>e!==s),S(t)},N=()=>{localStorage.removeItem("dbsync_dirty_tracks")};function B(s){return y("syncState","syncing"),C(s).then(({remoteMeta:t,ETag:e})=>{const n=w(),a={...n},r=[];for(const o in t){if(o==="version")continue;const c=t[o]||0,i=n[o]||0;c>i&&(console.log(`Pulling ${o}: remote is newer.`),o!=="tracks"&&r.push(x(c,o)),a[o]=c)}return Promise.all(r).then(()=>({finalMeta:a,ETag:e,remoteMeta:t,localMeta:n}))}).then(({finalMeta:t,ETag:e,remoteMeta:n,localMeta:a})=>{const r=[];for(const o of g()){const c=a[o]||0,i=n[o]||0;if(c>i){console.log(`Pushing ${o}: local is newer.`);const d=k(o),u=m(),f=d.map(l=>u[l]).filter(Boolean);r.push(v(f).then(l=>{t[o]=l}))}}return Promise.all(r).then(()=>({finalMeta:t,ETag:e,remoteMeta:n,localMeta:a}))}).then(({finalMeta:t,ETag:e,remoteMeta:n,localMeta:a})=>{const r=a.tracks||0,o=n.tracks||0,c=m(),i=p();let d=Promise.resolve();if(i.added.length>0||i.deleted.length>0){console.log("Pushing dirty track changes.");const u=i.added.map(f=>c[f]).filter(Boolean);d=E(s,u,i.deleted).then(()=>{N(),t.tracks=Date.now()})}else if(o>r){console.log("Pulling track changes.");const u=new Set;for(const l of g())k(l).forEach($=>u.add($));const f=[...u].filter(l=>!c[l]);f.length>0?d=J(s,f).then(()=>{t.tracks=o}):t.tracks=o}else r>o&&(console.log("Local tracks timestamp is newer, but no dirty tracks. Pushing all local tracks."),d=O(s,Object.values(c)).then(()=>{t.tracks=r}));return d.then(()=>({finalMeta:t,ETag:e,remoteMeta:n}))}).then(({finalMeta:t,ETag:e,remoteMeta:n})=>{if(JSON.stringify(t)!==JSON.stringify(n))return console.log("Finalizing sync..."),j(s,e,t)}).then(()=>(console.log("Sync complete."),y("syncState","synced"),{success:!0,message:"Sync complete."})).catch(t=>{console.error("Sync failed:",t);let e;return t instanceof Error?e=t.message:e=String(t),e.includes("412")?(y("syncState","error"),{success:!1,message:"Conflict detected. Please try again."}):(y("syncState","error"),{success:!1,message:`Sync failed: ${e}`})})}export{_ as addDirtyTrack,N as clearDirtyTracks,j as finalizeSync,p as getDirtyTracks,C as getRemoteManifest,x as pullContentByTimestamp,J as pullTrackMetadata,O as pushBulkTrackChanges,v as pushImmutableContent,E as pushTrackChanges,F as removeDirtyTrack,B as runSync,S as saveDirtyTracks,I as scheduleSync};
